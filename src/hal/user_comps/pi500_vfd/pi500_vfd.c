/* Autogenerated by ../bin/halcompile on Sun Sep  5 21:18:11 2021 -- do not edit */
#include "rtapi.h"
#ifdef RTAPI
#include "rtapi_app.h"
#endif
#include "rtapi_string.h"
#include "rtapi_errno.h"
#include "hal.h"
#include "rtapi_math64.h"

static int comp_id;

#ifdef MODULE_INFO
MODULE_INFO(linuxcnc, "component:pi500_vfd:Powtran PI500 modbus driver");
MODULE_INFO(linuxcnc, "param:mbslaveaddr:u32:0:rw:Modbus slave address:None:None");
MODULE_INFO(linuxcnc, "pin:commanded_frequency:float:0:in:Frequency of vfd:None:None");
MODULE_INFO(linuxcnc, "pin:run:bit:0:in:run the vfd:None:None");
MODULE_INFO(linuxcnc, "pin:enable:bit:0:in:1 to enable the vfd. 0 will remote trip the vfd, thereby disabling it.:None:None");
MODULE_INFO(linuxcnc, "pin:is_running:bit:0:out:1 when running:None:None");
MODULE_INFO(linuxcnc, "pin:is_at_speed:bit:0:out:1 when running at assigned frequency:None:None");
MODULE_INFO(linuxcnc, "pin:is_ready:bit:0:out:1 when vfd is ready to run:None:None");
MODULE_INFO(linuxcnc, "pin:is_alarm:bit:0:out:1 when vfd alarm is set:None:None");
MODULE_INFO(linuxcnc, "pin:motor_current:float:0:out:Output current in amps:None:None");
MODULE_INFO(linuxcnc, "pin:heatsink_temp:float:0:out:Temperature of drive heatsink:None:None");
MODULE_INFO(linuxcnc, "pin:watchdog_out:bit:0:out:Alternates between 1 and 0 after every update cycle. Feed into a watchdog component to ensure vfd driver is communicating with the vfd properly.:None:None");
MODULE_INFO(linuxcnc, "license:GPLv2 or greater");
MODULE_LICENSE("GPLv2 or greater");
#endif // MODULE_INFO


struct __comp_state {
    struct __comp_state *_next;
    hal_float_t *commanded_frequency;
    hal_bit_t *run;
    hal_bit_t *enable;
    hal_bit_t *is_running;
    hal_bit_t *is_at_speed;
    hal_bit_t *is_ready;
    hal_bit_t *is_alarm;
    hal_float_t *motor_current;
    hal_float_t *heatsink_temp;
    hal_bit_t *watchdog_out;
    hal_u32_t mbslaveaddr;
};
#include <stdlib.h>
struct __comp_state *__comp_first_inst=0, *__comp_last_inst=0;

static int __comp_get_data_size(void);
#undef TRUE
#define TRUE (1)
#undef FALSE
#define FALSE (0)
#undef true
#define true (1)
#undef false
#define false (0)

static int export(char *prefix, long extra_arg) {
    int r = 0;
    int sz = sizeof(struct __comp_state) + __comp_get_data_size();
    struct __comp_state *inst = hal_malloc(sz);
    memset(inst, 0, sz);
    r = hal_pin_float_newf(HAL_IN, &(inst->commanded_frequency), comp_id,
        "%s.commanded-frequency", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->run), comp_id,
        "%s.run", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->enable), comp_id,
        "%s.enable", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->is_running), comp_id,
        "%s.is-running", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->is_at_speed), comp_id,
        "%s.is-at-speed", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->is_ready), comp_id,
        "%s.is-ready", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->is_alarm), comp_id,
        "%s.is-alarm", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->motor_current), comp_id,
        "%s.motor-current", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->heatsink_temp), comp_id,
        "%s.heatsink-temp", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->watchdog_out), comp_id,
        "%s.watchdog-out", prefix);
    if(r != 0) return r;
    r = hal_param_u32_newf(HAL_RW, &(inst->mbslaveaddr), comp_id,
        "%s.mbslaveaddr", prefix);
    if(r != 0) return r;
    if(__comp_last_inst) __comp_last_inst->_next = inst;
    __comp_last_inst = inst;
    if(!__comp_first_inst) __comp_first_inst = inst;
    return 0;
}
static int default_count=1, count=0;
char *names[16] = {0,};
int rtapi_app_main(void) {
    int r = 0;
    int i;
    comp_id = hal_init("pi500_vfd");
    if(comp_id < 0) return comp_id;
    if(count && names[0]) {
        rtapi_print_msg(RTAPI_MSG_ERR,"count= and names= are mutually exclusive\n");
        return -EINVAL;
    }
    if(!count && !names[0]) count = default_count;
    if(count) {
        for(i=0; i<count; i++) {
            char buf[HAL_NAME_LEN + 1];
            rtapi_snprintf(buf, sizeof(buf), "pi500-vfd.%d", i);
            r = export(buf, i);
            if(r != 0) break;
       }
    } else {
        int max_names = sizeof(names)/sizeof(names[0]);
        for(i=0; (i < max_names) && names[i]; i++) {
            if (strlen(names[i]) < 1) {
                rtapi_print_msg(RTAPI_MSG_ERR, "names[%d] is invalid (empty string)\n", i);
                r = -EINVAL;
                break;
            }
            r = export(names[i], i);
            if(r != 0) break;
       }
    }
    if(r) {
        hal_exit(comp_id);
    } else {
        hal_ready(comp_id);
    }
    return r;
}

void rtapi_app_exit(void) {
    hal_exit(comp_id);
}
static void user_mainloop(void);
static void userinit(int argc, char **argv);

int __comp_parse_count(int *argc, char **argv) {
    int i;
    for (i = 0; i < *argc; i ++) {
        if (strncmp(argv[i], "count=", 6) == 0) {
            errno = 0;
            count = strtoul(&argv[i][6], NULL, 0);
            for (; i+1 < *argc; i ++) {
                argv[i] = argv[i+1];
            }
            argv[i] = NULL;
            (*argc)--;
            if (errno == 0) {
                return 1;
            }
        }
    }
    return 0;
}


int __comp_parse_names(int *argc, char **argv) {
    int i;
    for (i = 0; i < *argc; i ++) {
        if (strncmp(argv[i], "names=", 6) == 0) {
            char *p = &argv[i][6];
            int j;
            for (; i+1 < *argc; i ++) {
                argv[i] = argv[i+1];
            }
            argv[i] = NULL;
            (*argc)--;
            for (j = 0; j < 16; j ++) {
                names[j] = strtok(p, ",");
                p = NULL;
                if (names[j] == NULL) {
                    return 1;
                }
            }
            return 1;
        }
    }
    return 0;
}

int argc=0; char **argv=0;
int main(int argc_, char **argv_) {
    argc = argc_; argv = argv_;
    int found_count, found_names;
    found_count = __comp_parse_count(&argc, argv);
    found_names = __comp_parse_names(&argc, argv);
    if (found_count && found_names) {
        rtapi_print_msg(RTAPI_MSG_ERR, "count= and names= are mutually exclusive\n");
        return 1;
    }
    userinit(argc, argv);

    if(rtapi_app_main() < 0) return 1;
    user_mainloop();
    rtapi_app_exit();
    return 0;
}

#undef FUNCTION
#define FUNCTION(name) static void name(struct __comp_state *__comp_inst, long period)
#undef EXTRA_SETUP
#define EXTRA_SETUP() static int extra_setup(struct __comp_state *__comp_inst, char *prefix, long extra_arg)
#undef EXTRA_CLEANUP
#define EXTRA_CLEANUP() static void extra_cleanup(void)
#undef fperiod
#define fperiod (period * 1e-9)
#undef commanded_frequency
#define commanded_frequency (0+*__comp_inst->commanded_frequency)
#undef run
#define run (0+*__comp_inst->run)
#undef enable
#define enable (0+*__comp_inst->enable)
#undef is_running
#define is_running (*__comp_inst->is_running)
#undef is_at_speed
#define is_at_speed (*__comp_inst->is_at_speed)
#undef is_ready
#define is_ready (*__comp_inst->is_ready)
#undef is_alarm
#define is_alarm (*__comp_inst->is_alarm)
#undef motor_current
#define motor_current (*__comp_inst->motor_current)
#undef heatsink_temp
#define heatsink_temp (*__comp_inst->heatsink_temp)
#undef watchdog_out
#define watchdog_out (*__comp_inst->watchdog_out)
#undef mbslaveaddr
#define mbslaveaddr (__comp_inst->mbslaveaddr)
#undef FOR_ALL_INSTS
#define FOR_ALL_INSTS() struct __comp_state *__comp_inst; for(__comp_inst = __comp_first_inst; __comp_inst; __comp_inst = __comp_inst->_next)


#line 17 "hal/user_comps/pi500_vfd/pi500_vfd.comp"
/*
  Userspace HAL component to control a Powtran PI500 series VFD. There are several
  VFDs which are based on the Powtran PI500, e.g., Sourcetronic ST500, Kinger Born PI500, etc.

  Written by Jan Roters, based on code from Curtis Dutton, inspired by vfs11_vfd.c in linuxcnc

  Copyright (C) 2021 Jan Roters

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation, version 2.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301-1307  USA.

  see 'man pi500_vfd' and the PI500 section in the Drivers manual.
*/
#include<stdio.h>
#include<errno.h>
#include<getopt.h>
#include<stdbool.h>
#include<math.h>
#include<modbus.h>
#include<unistd.h>
#include<ctype.h>

typedef struct
{
        uint8_t running;
        uint8_t ready;
        uint8_t at_speed;
        uint8_t alarm;
		float output_current;
		float sink_temp;
        uint16_t frequency;
        uint8_t freq_two_digits;
} pi500_status;

/*sets the operating frequency of the vfd*/
bool pi500_setFrequency(modbus_t* ctx, uint16_t frequency) {
        return modbus_write_register(ctx, 0xF001, frequency) > 0;
}

/*resets the trip status of the VFD*/
bool pi500_reset(modbus_t* ctx)
{
        /*after the reset, the pi500 vfd seem to need a second
        before it will reply to more modbus commands*/
        int rc = modbus_write_register(ctx, 0x2000, 7);

        sleep(1);

        return rc > 0;
}

/*bool pi500_trip(modbus_t* ctx)
{
        return modbus_write_bit(ctx, 0x002, TRUE) > 0;
}*/

bool pi500_run(modbus_t* ctx, bool runBit)
{
		uint16_t status = (runBit ? 1 : 6);
        return modbus_write_register(ctx, 0x2000, status) > 0;
}


bool pi500_getStatus(modbus_t* ctx, pi500_status* status)
{
	uint16_t running;
	uint16_t speed_setting;
	uint16_t two_digits;
	uint16_t status_params[8];
	uint16_t error_msg;

	// read current speed set (register 0xF001)
	if (modbus_read_registers(ctx, 0xF001, 1, &speed_setting) < 0) {
		return false;
	}
	
	if (modbus_read_registers(ctx, 0xF002, 1, &two_digits) < 0) {
		return false;
	}

	// read run status (register 0x3000)
	if (modbus_read_registers(ctx, 0x3000, 1, &running) < 0) {
		return false;
	}

	// read other status flags (register 0x1000 following)
	if (modbus_read_registers(ctx, 0x1000, 8, status_params) < 0) {
		return false;
	}
	
	// read error status (register 0x8000)
	if (modbus_read_registers(ctx, 0x8000, 1, &error_msg) < 0) {
		return false;
	}
		
	status->running = (running == 1 || running == 2);
	status->ready = (running == 3);
	status->alarm = (error_msg != 0);
	status->at_speed = 0;
	status->frequency = status_params[1];
	status->output_current = status_params[4];
	status->sink_temp = 0;
	status->freq_two_digits = (two_digits == 2);

	return true;
}

void print_modbus_error(struct __comp_state *__comp_inst, const char* msg)
{
	fprintf(stderr, 
		"Error: pi500_vfd slave(%d): %s - Modbus error (%d) -  %s\n",
		mbslaveaddr,
		msg,
		errno,
		modbus_strerror(errno));
}


/* modbus connection settings*/
char *device = "/dev/ttyS0";
int baud = 9600;
char parity = 'N';
int data_bits = 8;
int stop_bits = 1;
modbus_t *ctx;

void userinit(int argc, char **argv)
{
	int opt_index = 0;
	int c = 0;

	static struct option options[] = {
		{"baud",   required_argument, 0, 0 },
		{"parity", required_argument, 0, 0 },
		{"databits", required_argument, 0, 0 },
		{"stopbits", required_argument, 0, 0 },
		{"device", required_argument, 0, 0 },
		{0, 0, 0, 0}
	};	

	while(1) {
		c = getopt_long(argc, argv, "", options, &opt_index);

		if(c == -1)
			break;

		switch(opt_index) {
			case 0:
				baud = atoi(optarg);

				if(baud == 0)
				{
					fprintf(stderr, 
						"Invalid argument: buad must be a number. Given '%s'\n", 
						optarg);
					exit(1);
				}
				break;

			case 1:
				parity = toupper(optarg[0]);

				if(parity != 'E' && parity != 'O' && parity != 'N')
				{
					fprintf(stderr, 
						"Invalid argument: parity must be 'e', 'o' or 'n'. Given '%s'\n", 
						optarg);
					exit(1);
				}
				break;

			case 2:
				data_bits = atoi(optarg);

				if(data_bits == 0)
				{
					fprintf(stderr, 
						"Invalid argument: databits must be a number. Given '%s'\n", 
						optarg);
					exit(1);
				}
				break;

			case 3:
				stop_bits = atoi(optarg);
		
				if(stop_bits == 0)
				{
					fprintf(stderr, 
						"Invalid argument: stopbits must be a number. Given '%s'\n", 
						optarg);
					exit(1);
				}
				break;
			case 4:
				device = optarg;
				break;


			default:
                fprintf(stderr, "internal error: invalid option index!\n");
				exit(1);
		}

	}

        if (optind < argc) {
            fprintf(stderr, "WARNING: unhandled arguments to pi500_vfd driver:\n");
            for (int i = optind; i < argc; i ++) {
                fprintf(stderr, "    %s\n", argv[i]);
            }
        }

	ctx = modbus_new_rtu(device, baud, parity, data_bits, stop_bits);

	if (ctx == NULL) {
		fprintf(stderr, 
			"ERROR: pi500_vfd unable to create libmodbus context. - %s\n", 
			modbus_strerror(errno));
		fprintf(stderr, "Check your commandline!\n");
		exit(1);	
	}
		
	if (modbus_connect(ctx)) {
		fprintf(stderr, 
			"ERROR: pi500_vfd unable to create libmodbus connection. - %s\n", 
			modbus_strerror(errno));
		exit(1);
	}
}

void user_mainloop(void) {
	pi500_status status;
	uint16_t calculated_frequency;

	while(1) {
	FOR_ALL_INSTS() {
		/*
                  until the params are set we just wait a bit
		  and then skip to the next instance.

		  if every instance does not get a slave address,
                  this could cause bad behavior
		*/
		if(mbslaveaddr == 0) {
			sleep(1);
			continue; 
		}

		modbus_set_slave(ctx, mbslaveaddr);

		/*
                  for each slave, receive info from the slave,
		  update our output pins based upon vfd status,
		  then set the vfd according to our input pins

		  if we hit an error we just re-loop. The watchdog
		  pin won't change until we make it all the way through
		  the loop.
                */
		if(!pi500_getStatus(ctx, &status)) {	
			print_modbus_error(__comp_inst, "failed to get status");
			continue;
		}

		is_running = status.running;
		is_ready = status.ready;
		is_alarm = status.alarm;

		if(!status.alarm && !enable) { //  && !pi500_trip(ctx)
			print_modbus_error(__comp_inst, "failed to trip");
			continue;
		}
		else if(status.alarm && enable && !pi500_reset(ctx)) {
			print_modbus_error(__comp_inst, "failed to reset");
			continue;
		}
		else {
			calculated_frequency = (uint16_t)(fabs(commanded_frequency) * 10 * (status.freq_two_digits ? 10 : 1));

			is_at_speed = (commanded_frequency > 0 && calculated_frequency == status.frequency ? 1 : 0);
			
			if(commanded_frequency > 0 
				&& calculated_frequency != status.frequency 
				&& !pi500_setFrequency(ctx, calculated_frequency)) {
				
				print_modbus_error(__comp_inst, "failed to set frequency");
				continue;
			}
			
			if(status.running ^ run && !pi500_run(ctx, run)) {
				print_modbus_error(__comp_inst, "failed to run");
				continue;
			}

			watchdog_out = !watchdog_out;
			motor_current = status.output_current / 100;
			heatsink_temp = status.sink_temp / 10;
		}
	}
	}
}

static int __comp_get_data_size(void) { return 0; }
